<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robotics Field Animator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- FFmpeg.wasm will be loaded dynamically from CDN for better compatibility -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .controls-panel {
            scrollbar-width: thin;
            scrollbar-color: #4a5568 #2d3748;
        }
        .controls-panel::-webkit-scrollbar {
            width: 8px;
        }
        .controls-panel::-webkit-scrollbar-track {
            background: #2d3748;
        }
        .controls-panel::-webkit-scrollbar-thumb {
            background-color: #4a5568;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #38bdf8;
            cursor: pointer;
            border-radius: 50%;
            margin-top: -6px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #38bdf8;
            cursor: pointer;
            border-radius: 50%;
        }
        .custom-file-upload {
            border: 2px dashed #4a5568;
            display: inline-block;
            padding: 8px 12px;
            cursor: pointer;
            background-color: #2d3748;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .custom-file-upload:hover {
            border-color: #38bdf8;
            background-color: #4a5568;
        }
    </style>
    </head>
<body class="bg-gray-900 text-gray-200 flex flex-col md:flex-row h-screen overflow-hidden">

    <!-- Main Canvas Area -->
    <main class="flex-1 flex flex-col items-center justify-center p-4 bg-gray-800/50">
        <canvas id="robotCanvas" class="bg-gray-700 rounded-lg shadow-2xl max-w-full max-h-full"></canvas>
    </main>

    <!-- Controls Panel -->
    <aside class="w-full md:w-80 lg:w-96 bg-gray-800 p-6 shadow-lg overflow-y-auto controls-panel flex-shrink-0 h-1/2 md:h-full">
        <div class="space-y-6">
            <h1 class="text-2xl font-bold text-sky-400">Animator Controls</h1>
            
            <!-- Instructions -->
            <div class="bg-gray-700/50 p-4 rounded-lg text-sm text-gray-300">
                <h3 class="font-semibold text-lg mb-2 text-white">How to Use:</h3>
                <ol class="list-decimal list-inside space-y-1.5">
                    <li>Upload a field image/PDF.</li>
                    <li>Add sprites and upload images for each one.</li>
                    <li>Optional: Disable background to record with solid color.</li>
                    <li>Click on the field to add waypoints (even just 1!).</li>
                    <li>Drag waypoints to reposition them.</li>
                    <li>Hold SHIFT while dragging for straight lines!</li>
                    <li>Select a waypoint to edit heading and actions.</li>
                    <li>Use "Add Sprite Action" or "Duplicate" for stop-motion.</li>
                    <li>Adjust rotation for each action to rotate sprites.</li>
                    <li>Adjust playback speed for faster/slower animations.</li>
                    <li>Press 'Animate' to preview or 'Record' to save.</li>
                    <li>While recording: Press SPACE to pause, then drag to pan or scroll to zoom!</li>
                </ol>
            </div>

            <!-- Setup -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">Setup</h2>
                <div>
                    <label for="fieldUpload" class="custom-file-upload w-full text-center">
                        <span id="fieldFileName">Upload Field Image/PDF</span>
                        <input id="fieldUpload" type="file" class="hidden" accept="image/*,application/pdf">
                    </label>
                </div>
                
                <!-- Background Options -->
                <div class="bg-gray-700/50 p-3 rounded-lg space-y-3">
                    <h3 class="text-sm font-semibold text-gray-200">Background Options</h3>
                    <div class="flex items-center space-x-2">
                        <input id="useBackgroundCheckbox" type="checkbox" checked class="w-4 h-4 text-sky-600 bg-gray-700 border-gray-600 rounded focus:ring-sky-500">
                        <label for="useBackgroundCheckbox" class="text-sm text-gray-300">Use field image as background</label>
                    </div>
                    <div id="backgroundColorOption" class="space-y-2 hidden">
                        <label for="backgroundColorPicker" class="block text-sm text-gray-300">Background Color:</label>
                        <div class="flex items-center space-x-2">
                            <input id="backgroundColorPicker" type="color" value="#1f2937" class="w-12 h-8 rounded cursor-pointer bg-gray-700 border border-gray-600">
                            <span id="backgroundColorValue" class="text-xs text-gray-400">#1f2937</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sprite Manager -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">Sprites</h2>
                <div id="spriteList" class="space-y-2 bg-gray-700/50 p-3 rounded-lg max-h-60 overflow-y-auto">
                    <!-- Sprite instances will be listed here -->
                </div>
                <button id="addSpriteBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    + Add Sprite
                </button>
            </div>

            <!-- Waypoints List -->
            <div id="waypointsList" class="space-y-4 hidden">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">Waypoints</h2>
                <div id="waypointsListContainer" class="space-y-2 max-h-64 overflow-y-auto bg-gray-700/30 p-2 rounded-lg">
                    <!-- Waypoints will be dynamically inserted here -->
                </div>
            </div>

            <!-- Waypoint Editor -->
            <div id="waypointEditor" class="space-y-4 hidden">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">Edit Waypoint <span id="waypointId" class="text-sky-400"></span></h2>
                <div>
                    <label for="heading" class="block mb-2 font-medium">Heading: <span id="headingValue" class="font-bold text-sky-400">0Â°</span></label>
                    <input id="heading" type="range" min="0" max="360" value="0" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <!-- Stop Motion Actions -->
                <div class="space-y-3">
                    <h3 class="text-lg font-semibold">Stop-Motion Actions</h3>
                    <div id="stopActionsList" class="space-y-2 bg-gray-700/50 p-3 rounded-lg">
                        <!-- Actions will be dynamically inserted here -->
                    </div>
                    <input id="stopActionSpriteUpload" type="file" class="hidden" accept="image/*">
                    <button id="addStopActionBtn" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">
                        + Add Sprite Action
                    </button>
                    <button id="duplicateActionBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">
                        + Duplicate Last Action
                    </button>
                </div>

                <button id="deleteWaypoint" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Delete Waypoint
                </button>
            </div>

            <!-- View Controls -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">View Controls</h2>
                <div class="bg-gray-700/50 p-3 rounded-lg text-sm space-y-2">
                    <p class="text-gray-300">Pan & Zoom the canvas:</p>
                    <ul class="list-disc list-inside ml-2 space-y-1 text-gray-400 text-xs">
                        <li>Drag canvas to pan</li>
                        <li>Mouse wheel to zoom</li>
                        <li>Works anytime (not just during recording)</li>
                    </ul>
                </div>
                <button id="resetViewPreview" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Reset View
                </button>
                <div class="bg-gray-700/50 p-3 rounded-lg text-xs">
                    <p><strong>Pan:</strong> <span id="panInfoPreview">0, 0</span></p>
                    <p><strong>Zoom:</strong> <span id="zoomInfoPreview">100%</span></p>
                </div>
            </div>

            <!-- Animation Controls -->
            <div class="space-y-4">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">Animation</h2>
                <div>
                    <label for="speedSlider" class="block mb-2 font-medium">Playback Speed: <span id="speedValue" class="font-bold text-sky-400">1x</span></label>
                    <input id="speedSlider" type="range" min="0.25" max="3" step="0.25" value="1" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span>0.25x</span>
                        <span>3x</span>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button id="record" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Record</button>
                    <button id="animate" class="flex-1 bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Animate</button>
                    <button id="stop" class="flex-1 bg-amber-500 hover:bg-amber-600 text-white font-bold py-2 px-4 rounded-lg transition-colors">Stop</button>
                </div>
                
                <!-- Video Export Options (initially hidden) -->
                <div id="exportOptions" class="space-y-2 hidden">
                    <div class="flex space-x-2">
                        <button id="downloadWebm" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Download WebM</button>
                        <button id="convertGif" class="flex-1 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm">Convert to GIF</button>
                    </div>
                </div>
                
                <p id="gifStatus" class="text-xs text-gray-400 mt-1 hidden"></p>
                <button id="clear" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-colors">Clear All Waypoints</button>
            </div>
            
            <!-- Pan/Zoom Controls (shown during recording) -->
            <div id="panZoomControls" class="space-y-4 hidden">
                <h2 class="text-xl font-semibold border-b border-gray-600 pb-2">Recording Controls</h2>
                <div class="bg-blue-900/30 p-4 rounded-lg text-sm space-y-2">
                    <p class="font-semibold text-blue-300">Press SPACE to pause/resume animation</p>
                    <p class="text-gray-300">While paused:</p>
                    <ul class="list-disc list-inside ml-2 space-y-1 text-gray-400">
                        <li>Drag canvas to pan</li>
                        <li>Mouse wheel to zoom</li>
                        <li>Click "Reset View" to reset</li>
                    </ul>
                </div>
                <button id="resetView" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                    Reset View
                </button>
                <div class="bg-gray-700/50 p-3 rounded-lg text-xs">
                    <p><strong>Pan:</strong> <span id="panInfo">0, 0</span></p>
                    <p><strong>Zoom:</strong> <span id="zoomInfo">100%</span></p>
                    <p><strong>Status:</strong> <span id="pauseStatus" class="text-green-400">Recording</span></p>
                </div>
            </div>

             <!-- Info -->
            <div id="infoBox" class="bg-yellow-900/50 p-4 rounded-lg text-sm text-yellow-200 hidden">
                 <p id="infoText"></p>
            </div>

        </div>
    </aside>

    <!-- Rename Modal -->
    <div id="renameModal" class="fixed inset-0 z-50 bg-black/60 hidden items-center justify-center">
        <div class="bg-gray-800 border border-gray-700 rounded-lg shadow-2xl w-11/12 max-w-md p-5">
            <h3 class="text-lg font-semibold text-white">Save recording</h3>
            <p class="text-sm text-gray-300 mt-1">Choose a filename. This will be used for WebM and GIF.</p>
            <label class="block text-sm text-gray-300 mt-4 mb-1" for="renameInput">File name (no extension)</label>
            <input id="renameInput" type="text" class="w-full bg-gray-900 border border-gray-700 rounded px-3 py-2 text-gray-100 focus:outline-none focus:ring-2 focus:ring-sky-600" placeholder="robot-animation" />
            <p class="text-xs text-gray-400 mt-2">Will be saved as .webm and reused for .gif.</p>
            <div class="flex flex-wrap justify-end gap-2 mt-5">
                <button id="renameCancel" class="px-4 py-2 rounded bg-gray-700 hover:bg-gray-600 text-gray-100">Cancel</button>
                <button id="renameSaveWebM" class="px-4 py-2 rounded bg-sky-600 hover:bg-sky-700 text-white font-semibold">Save as WebM</button>
                <button id="renameSaveGIF" class="px-4 py-2 rounded bg-fuchsia-600 hover:bg-fuchsia-700 text-white font-semibold">Save as GIF</button>
            </div>
        </div>
    </div>

<script>
    // Optional Cloudinary client-only fallback (no server needed)
    // Cloudinary is the PRIMARY method for GIF conversion (more reliable than FFmpeg.wasm)
    // 1) Create a free Cloudinary account at https://cloudinary.com
    // 2) In Settings > Upload, create an UNSIGNED upload preset (e.g., 'unsigned')
    // 3) Set cloudName and uploadPreset below, and set enabled: true
    const cloudinaryConfig = {
        enabled: true, // Set to true to use Cloudinary for GIF conversion
        cloudName: 'dticademn', // your Cloudinary cloud name
        uploadPreset: 'unsigned', // your unsigned preset name
    };
    const canvas = document.getElementById('robotCanvas');
    const ctx = canvas.getContext('2d');

    const fieldUpload = document.getElementById('fieldUpload');
    const stopActionSpriteUpload = document.getElementById('stopActionSpriteUpload');
    
    const fieldFileName = document.getElementById('fieldFileName');

    const headingSlider = document.getElementById('heading');
    const headingValue = document.getElementById('headingValue');
    const animateBtn = document.getElementById('animate');
    const stopBtn = document.getElementById('stop');
    const clearBtn = document.getElementById('clear');
    const deleteWaypointBtn = document.getElementById('deleteWaypoint');
    const recordBtn = document.getElementById('record');
    const convertGifBtn = document.getElementById('convertGif');
    const downloadWebmBtn = document.getElementById('downloadWebm');
    const exportOptions = document.getElementById('exportOptions');
    const gifStatus = document.getElementById('gifStatus');
    // Rename modal elements
    const renameModal = document.getElementById('renameModal');
    const renameInput = document.getElementById('renameInput');
    const renameSaveWebMBtn = document.getElementById('renameSaveWebM');
    const renameSaveGIFBtn = document.getElementById('renameSaveGIF');
    const renameCancelBtn = document.getElementById('renameCancel');
    
    const waypointEditor = document.getElementById('waypointEditor');
    const waypointId = document.getElementById('waypointId');
    const infoBox = document.getElementById('infoBox');
    const infoText = document.getElementById('infoText');
    const stopActionsList = document.getElementById('stopActionsList');
    const addStopActionBtn = document.getElementById('addStopActionBtn');
    const duplicateActionBtn = document.getElementById('duplicateActionBtn');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    
    const waypointsList = document.getElementById('waypointsList');
    const waypointsListContainer = document.getElementById('waypointsListContainer');
    
    const panZoomControls = document.getElementById('panZoomControls');
    const resetViewBtn = document.getElementById('resetView');
    const panInfo = document.getElementById('panInfo');
    const zoomInfo = document.getElementById('zoomInfo');
    const pauseStatus = document.getElementById('pauseStatus');
    
    const resetViewPreviewBtn = document.getElementById('resetViewPreview');
    const panInfoPreview = document.getElementById('panInfoPreview');
    const zoomInfoPreview = document.getElementById('zoomInfoPreview');
    
    const useBackgroundCheckbox = document.getElementById('useBackgroundCheckbox');
    const backgroundColorOption = document.getElementById('backgroundColorOption');
    const backgroundColorPicker = document.getElementById('backgroundColorPicker');
    const backgroundColorValue = document.getElementById('backgroundColorValue');
    
    const spriteList = document.getElementById('spriteList');
    const addSpriteBtn = document.getElementById('addSpriteBtn');


    let fieldImage = null;
    let robotSprites = []; // Global store for all unique sprite images
    
    // Multi-sprite system
    let spriteInstances = []; // Array of sprite objects, each with waypoints and state
    let activeSpriteIndex = 0; // Which sprite is currently selected for editing
    
    let selectedWaypointIndex = -1;
    let animationFrameId = null;
    let playbackSpeed = 1; // Animation playback speed multiplier
    
    // Background options
    let useBackground = true;
    let backgroundColor = '#1f2937';

    // --- Recording State ---
    let mediaRecorder;
    let recordedChunks = [];
    let isRecording = false;
    let lastRecordingBlob = null; // Most recent WebM blob for optional GIF conversion
    let lastRecordingBaseName = 'robot-animation'; // Carries over to GIF name

    // --- FFmpeg (wasm) state ---
    let ffmpegInstance = null;
    let ffmpegLoaded = false;

    // --- Pan/Zoom State ---
    let isPaused = false;
    let panX = 0;
    let panY = 0;
    let zoomLevel = 1;
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let dragStartPanX = 0;
    let dragStartPanY = 0;
    
    // --- Waypoint Dragging State ---
    let isDraggingWaypoint = false;
    let draggedWaypointIndex = -1;
    let hoveredWaypointIndex = -1;
    let isShiftPressed = false;

    // --- Sprite Instance Helpers ---
    function createSpriteInstance(name) {
        return {
            name: name,
            waypoints: [],
            defaultSpriteIndex: 0, // Default sprite image to use for new waypoints
            size: 50, // Visual size of the sprite on canvas
            isStatic: false, // If true, sprite is static (no waypoints, fixed position)
            staticX: 400, // X position for static sprite
            staticY: 300, // Y position for static sprite
            staticHeading: 0, // Heading for static sprite
            state: {
                x: 0,
                y: 0,
                heading: 0,
                spriteIndex: 0,
                segmentIndex: 0,
                progress: 0,
                baseSpeed: 2,
                baseRotationSpeed: 3,
                phase: 'idle',
                actionIndex: 0,
                dwellCounter: 0,
            }
        };
    }
    
    function getActiveSprite() {
        if (spriteInstances.length === 0) {
            spriteInstances.push(createSpriteInstance('Sprite 1'));
            activeSpriteIndex = 0;
            renderSpriteList();
        }
        return spriteInstances[activeSpriteIndex];
    }
    
    // Sprite list management
    function renderSpriteList() {
        spriteList.innerHTML = '';
        spriteInstances.forEach((sprite, index) => {
            const spriteItem = document.createElement('div');
            spriteItem.className = `flex flex-col space-y-2 p-2 rounded transition-colors ${
                index === activeSpriteIndex ? 'bg-sky-600' : 'bg-gray-600 hover:bg-gray-500'
            }`;
            
            const topRow = document.createElement('div');
            topRow.className = 'flex items-center justify-between';
            
            const leftSide = document.createElement('div');
            leftSide.className = 'flex items-center space-x-2 flex-1 cursor-pointer';
            leftSide.onclick = () => selectSprite(index);
            
            const spriteName = document.createElement('span');
            spriteName.textContent = sprite.isStatic ? `${sprite.name} (static)` : `${sprite.name} (${sprite.waypoints.length} waypoints)`;
            spriteName.className = 'text-sm';
            
            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = 'Ã—';
            deleteBtn.className = 'text-red-400 hover:text-red-300 font-bold text-xl px-2';
            deleteBtn.onclick = (e) => {
                e.stopPropagation();
                deleteSprite(index);
            };
            
            leftSide.appendChild(spriteName);
            topRow.appendChild(leftSide);
            if (spriteInstances.length > 1) {
                topRow.appendChild(deleteBtn);
            }
            
            // Add upload sprite button
            const uploadBtn = document.createElement('button');
            uploadBtn.innerHTML = 'ðŸ“ Upload Sprite Image';
            uploadBtn.className = 'w-full bg-gray-700 hover:bg-gray-600 text-white text-xs py-1 px-2 rounded transition-colors';
            uploadBtn.onclick = (e) => {
                e.stopPropagation();
                uploadSpriteForInstance(index);
            };
            
            spriteItem.appendChild(topRow);
            spriteItem.appendChild(uploadBtn);
            spriteList.appendChild(spriteItem);
        });
        
        // Add controls for the active sprite
        if (spriteInstances.length > 0) {
            const activeSprite = spriteInstances[activeSpriteIndex];
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'mt-3 pt-3 border-t border-gray-600 space-y-3';
            
            // Static sprite checkbox
            const staticCheckbox = document.createElement('div');
            staticCheckbox.className = 'flex items-center space-x-2';
            staticCheckbox.innerHTML = `
                <input id="staticSpriteCheckbox" type="checkbox" ${activeSprite.isStatic ? 'checked' : ''} class="w-4 h-4 text-sky-600 bg-gray-700 border-gray-600 rounded focus:ring-sky-500">
                <label for="staticSpriteCheckbox" class="text-sm text-gray-300">Static Sprite (fixed position)</label>
            `;
            controlsDiv.appendChild(staticCheckbox);
            
            // Static position controls (only show if static)
            if (activeSprite.isStatic) {
                const staticControls = document.createElement('div');
                staticControls.className = 'space-y-2 pl-6 text-xs';
                staticControls.innerHTML = `
                    <div>
                        <label class="block mb-1">X Position: <span id="staticXValue" class="font-bold text-sky-400">${activeSprite.staticX}</span></label>
                        <input id="staticXSlider" type="range" min="0" max="1200" value="${activeSprite.staticX}" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label class="block mb-1">Y Position: <span id="staticYValue" class="font-bold text-sky-400">${activeSprite.staticY}</span></label>
                        <input id="staticYSlider" type="range" min="0" max="1200" value="${activeSprite.staticY}" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div>
                        <label class="block mb-1">Heading: <span id="staticHeadingValue" class="font-bold text-sky-400">${activeSprite.staticHeading}Â°</span></label>
                        <input id="staticHeadingSlider" type="range" min="0" max="359" value="${activeSprite.staticHeading}" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                `;
                controlsDiv.appendChild(staticControls);
            }
            
            // Size control
            const sizeControl = document.createElement('div');
            sizeControl.innerHTML = `
                <label class="block mb-2 font-medium text-sm">Sprite Size: <span id="spriteSizeValue" class="font-bold text-sky-400">${activeSprite.size}px</span></label>
                <input id="spriteSizeSlider" type="range" min="10" max="500" value="${activeSprite.size}" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            `;
            controlsDiv.appendChild(sizeControl);
            
            spriteList.appendChild(controlsDiv);
            
            // Attach event listeners
            const staticCheckboxEl = document.getElementById('staticSpriteCheckbox');
            staticCheckboxEl.addEventListener('change', (e) => {
                activeSprite.isStatic = e.target.checked;
                renderSpriteList();
                renderWaypointsList();
                draw();
            });
            
            const sizeSlider = document.getElementById('spriteSizeSlider');
            sizeSlider.addEventListener('input', (e) => {
                const newSize = parseInt(e.target.value);
                activeSprite.size = newSize;
                document.getElementById('spriteSizeValue').textContent = `${newSize}px`;
                draw();
            });
            
            if (activeSprite.isStatic) {
                const staticXSlider = document.getElementById('staticXSlider');
                staticXSlider.addEventListener('input', (e) => {
                    activeSprite.staticX = parseInt(e.target.value);
                    document.getElementById('staticXValue').textContent = activeSprite.staticX;
                    draw();
                });
                
                const staticYSlider = document.getElementById('staticYSlider');
                staticYSlider.addEventListener('input', (e) => {
                    activeSprite.staticY = parseInt(e.target.value);
                    document.getElementById('staticYValue').textContent = activeSprite.staticY;
                    draw();
                });
                
                const staticHeadingSlider = document.getElementById('staticHeadingSlider');
                staticHeadingSlider.addEventListener('input', (e) => {
                    activeSprite.staticHeading = parseInt(e.target.value);
                    document.getElementById('staticHeadingValue').textContent = `${activeSprite.staticHeading}Â°`;
                    draw();
                });
            }
        }
    }
    
    function uploadSpriteForInstance(spriteIndex) {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file || !file.type.startsWith('image/')) {
                showInfo('Please upload a valid image file.');
                return;
            }
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    // Add to global sprite images array
                    robotSprites.push(img);
                    const newSpriteIndex = robotSprites.length - 1;
                    
                    // Update this sprite instance to use the new sprite
                    const sprite = spriteInstances[spriteIndex];
                    sprite.defaultSpriteIndex = newSpriteIndex;
                    
                    // Update all waypoints for this sprite to use the new sprite
                    sprite.waypoints.forEach(wp => {
                        wp.stopActions.forEach(action => {
                            action.spriteIndex = newSpriteIndex;
                        });
                    });
                    
                    showInfo(`Sprite image uploaded for ${sprite.name}`);
                    draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };
        input.click();
    }
    
    function selectSprite(index) {
        activeSpriteIndex = index;
        selectedWaypointIndex = -1;
        waypointEditor.classList.add('hidden');
        renderSpriteList();
        renderWaypointsList();
        draw();
    }
    
    function addSprite() {
        const newIndex = spriteInstances.length + 1;
        spriteInstances.push(createSpriteInstance(`Sprite ${newIndex}`));
        selectSprite(spriteInstances.length - 1);
    }
    
    function deleteSprite(index) {
        if (spriteInstances.length === 1) {
            showInfo("Cannot delete the last sprite");
            return;
        }
        spriteInstances.splice(index, 1);
        if (activeSpriteIndex >= spriteInstances.length) {
            activeSpriteIndex = spriteInstances.length - 1;
        }
        selectedWaypointIndex = -1;
        waypointEditor.classList.add('hidden');
        renderSpriteList();
        renderWaypointsList();
        draw();
    }

    // --- State Management ---
    function init() {
        // Initialize PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }
        
        // Set initial cursor style
        canvas.style.cursor = 'grab';
        
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        fieldUpload.addEventListener('change', handleFieldUpload);

        stopActionSpriteUpload.addEventListener('change', handleFileUpload(img => {
             if (selectedWaypointIndex !== -1) {
                robotSprites.push(img);
                const newSpriteIndex = robotSprites.length - 1;
                const sprite = getActiveSprite();
                sprite.waypoints[selectedWaypointIndex].stopActions.push({
                    spriteIndex: newSpriteIndex,
                    duration: 30,
                    rotation: 0 // Default rotation
                });
                renderStopActions(selectedWaypointIndex);
                draw();
            }
        }, 'stop action sprite'));

        canvas.addEventListener('click', handleCanvasClick);
        headingSlider.addEventListener('input', handleHeadingChange);
        addStopActionBtn.addEventListener('click', () => stopActionSpriteUpload.click());
        duplicateActionBtn.addEventListener('click', handleDuplicateAction);
        speedSlider.addEventListener('input', handleSpeedChange);
        animateBtn.addEventListener('click', startAnimation);
        stopBtn.addEventListener('click', stopAnimation);
        clearBtn.addEventListener('click', clearWaypoints);
        deleteWaypointBtn.addEventListener('click', deleteSelectedWaypoint);
        recordBtn.addEventListener('click', toggleRecording);
        if (convertGifBtn) {
            convertGifBtn.addEventListener('click', convertRecordedToGIF);
        }
        if (downloadWebmBtn) {
            downloadWebmBtn.addEventListener('click', () => {
                const base = lastRecordingBaseName || 'robot-animation';
                downloadRecordedWithName(base);
            });
        }
        renameSaveWebMBtn.addEventListener('click', onRenameSaveWebM);
        renameSaveGIFBtn.addEventListener('click', onRenameSaveGIF);
        renameCancelBtn.addEventListener('click', onRenameCancel);
        renameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); onRenameSaveWebM(); }
            if (e.key === 'Escape') { e.preventDefault(); onRenameCancel(); }
        });
        
        // Sprite management
        addSpriteBtn.addEventListener('click', addSprite);
        getActiveSprite(); // Initialize first sprite
        renderSpriteList();
        
        // Pan/Zoom event listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('wheel', handleWheel, { passive: false });
        document.addEventListener('keydown', handleKeyDown);
        resetViewBtn.addEventListener('click', resetView);
        resetViewPreviewBtn.addEventListener('click', resetView);
        
        // Background options listeners
        useBackgroundCheckbox.addEventListener('change', handleBackgroundCheckboxChange);
        backgroundColorPicker.addEventListener('input', handleBackgroundColorChange);
    }
    
    function handleBackgroundCheckboxChange() {
        useBackground = useBackgroundCheckbox.checked;
        if (useBackground) {
            backgroundColorOption.classList.add('hidden');
        } else {
            backgroundColorOption.classList.remove('hidden');
        }
        draw();
    }
    
    function handleBackgroundColorChange() {
        backgroundColor = backgroundColorPicker.value;
        backgroundColorValue.textContent = backgroundColor;
        draw();
    }

    function resizeCanvas() {
        const container = canvas.parentElement;
        const containerRect = container.getBoundingClientRect();
        let newWidth = containerRect.width;
        let newHeight = containerRect.height;
        if (fieldImage && useBackground) {
            const aspectRatio = fieldImage.width / fieldImage.height;
            if (newWidth / newHeight > aspectRatio) {
                newWidth = newHeight * aspectRatio;
            } else {
                newHeight = newWidth / aspectRatio;
            }
        } else {
            // Use full container size when no background or background disabled
            newWidth = Math.min(newWidth, 800);
            newHeight = Math.min(newHeight, 600);
        }
        canvas.width = newWidth;
        canvas.height = newHeight;
        draw();
    }

    // --- File Handling ---
    function handleFieldUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        if (file.type === 'application/pdf') {
            loadPDFAsImage(file);
        } else if (file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    fieldImage = img;
                    fieldFileName.textContent = file.name;
                    resizeCanvas();
                    draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        } else {
            showInfo('Error: Please upload a valid image or PDF file.');
        }
    }

    async function loadPDFAsImage(file) {
        if (typeof pdfjsLib === 'undefined') {
            showInfo('Error: PDF support is not available.');
            return;
        }
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            const page = await pdf.getPage(1); // Get first page
            
            const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better quality
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;
            
            await page.render({
                canvasContext: tempCtx,
                viewport: viewport
            }).promise;
            
            // Convert canvas to image
            const img = new Image();
            img.onload = function() {
                fieldImage = img;
                fieldFileName.textContent = file.name;
                resizeCanvas();
                draw();
            };
            img.src = tempCanvas.toDataURL();
            
        } catch (error) {
            console.error('Error loading PDF:', error);
            showInfo('Error: Failed to load PDF. Please try an image file instead.');
        }
    }

    function handleFileUpload(callback, type) {
        return function(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (!file.type.startsWith('image/')){
                showInfo(`Error: Please upload a valid image file for the ${type}.`);
                return;
            }
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() { callback(img); };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
    }

    // --- User Interaction Handlers ---
    function handleCanvasClick(e) {
        if (animationFrameId || isRecording || isDragging || isDraggingWaypoint) return;
        
        const sprite = getActiveSprite();
        
        // Prevent adding waypoints to static sprites
        if (sprite.isStatic) {
            return;
        }
        
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        // Account for pan and zoom transformations
        const x = ((e.clientX - rect.left) * scaleX - panX) / zoomLevel;
        const y = ((e.clientY - rect.top) * scaleY - panY) / zoomLevel;

        const clickedWaypointIndex = sprite.waypoints.findIndex(wp => Math.sqrt((wp.x - x)**2 + (wp.y - y)**2) < 15);

        if (clickedWaypointIndex !== -1) {
            selectWaypoint(clickedWaypointIndex);
        } else {
            // Allow waypoints without background if "no background" option is selected
            if (robotSprites.length === 0) {
                showInfo("Please upload an initial robot sprite first.");
                return;
            }
            if (useBackground && !fieldImage) {
                showInfo("Please upload a field image or disable 'Use field image as background'.");
                return;
            }
            const lastWaypoint = sprite.waypoints[sprite.waypoints.length - 1];
            // Use sprite's default sprite index, or fallback to last waypoint's sprite, or 0
            const lastSpriteIndex = lastWaypoint ? 
                lastWaypoint.stopActions[lastWaypoint.stopActions.length - 1].spriteIndex : 
                (sprite.defaultSpriteIndex !== undefined ? sprite.defaultSpriteIndex : 0);
            const lastRotation = lastWaypoint ? lastWaypoint.stopActions[lastWaypoint.stopActions.length - 1].rotation : 0;
            
            sprite.waypoints.push({
                x, y,
                heading: lastWaypoint ? lastWaypoint.heading : 0,
                stopActions: [{ spriteIndex: lastSpriteIndex, duration: 1, rotation: lastRotation }],
            });
            selectWaypoint(sprite.waypoints.length - 1);
            renderSpriteList();
        }
        draw();
    }
    
    function selectWaypoint(index) {
        selectedWaypointIndex = index;
        const sprite = getActiveSprite();
        const wp = sprite.waypoints[index];
        waypointEditor.classList.remove('hidden');
        waypointId.textContent = `#${index + 1}`;
        headingSlider.value = wp.heading;
        headingValue.textContent = `${wp.heading}Â°`;
        renderStopActions(index);
        renderWaypointsList();
    }
    
    function renderWaypointsList() {
        const sprite = getActiveSprite();
        if (sprite.waypoints.length === 0) {
            waypointsList.classList.add('hidden');
            return;
        }
        
        waypointsList.classList.remove('hidden');
        waypointsListContainer.innerHTML = '';
        
        sprite.waypoints.forEach((wp, index) => {
            const wpItem = document.createElement('div');
            wpItem.className = `flex items-center justify-between p-2 rounded cursor-pointer transition-colors ${
                index === selectedWaypointIndex 
                    ? 'bg-sky-600 text-white' 
                    : 'bg-gray-700/50 hover:bg-gray-600/50 text-gray-200'
            }`;
            
            wpItem.innerHTML = `
                <div class="flex items-center space-x-2">
                    <span class="font-semibold text-sm">Waypoint ${index + 1}</span>
                </div>
                <div class="text-xs">
                    <span class="opacity-75">Heading:</span>
                    <span class="font-bold ml-1">${wp.heading}Â°</span>
                </div>
            `;
            
            wpItem.addEventListener('click', () => {
                selectWaypoint(index);
                draw();
            });
            
            waypointsListContainer.appendChild(wpItem);
        });
    }
    
    function handleSpeedChange(e) {
        playbackSpeed = parseFloat(e.target.value);
        speedValue.textContent = `${playbackSpeed}x`;
    }

    function handleDuplicateAction() {
        if (selectedWaypointIndex !== -1) {
            const sprite = getActiveSprite();
            const wp = sprite.waypoints[selectedWaypointIndex];
            if (wp.stopActions.length > 0) {
                const lastAction = wp.stopActions[wp.stopActions.length - 1];
                wp.stopActions.push({
                    spriteIndex: lastAction.spriteIndex,
                    duration: lastAction.duration,
                    rotation: lastAction.rotation
                });
                renderStopActions(selectedWaypointIndex);
                draw();
            }
        }
    }

    function renderStopActions(waypointIndex) {
        stopActionsList.innerHTML = '';
        const sprite = getActiveSprite();
        const wp = sprite.waypoints[waypointIndex];
        if (!wp.stopActions || wp.stopActions.length === 0) {
            stopActionsList.innerHTML = `<p class="text-xs text-gray-400">No actions defined. Add one!</p>`;
            return;
        }

        wp.stopActions.forEach((action, actionIndex) => {
            const actionEl = document.createElement('div');
            actionEl.className = 'flex flex-col space-y-2 bg-gray-800 p-2 rounded mb-2';

            const spriteImg = robotSprites[action.spriteIndex];
            const imgSrc = spriteImg ? spriteImg.src : 'https://placehold.co/32x32/374151/9ca3af?text=?';
            
            // Ensure rotation exists (for backwards compatibility)
            if (action.rotation === undefined) action.rotation = 0;

            actionEl.innerHTML = `
                <div class="flex items-center space-x-2">
                    <img src="${imgSrc}" class="w-8 h-8 rounded border border-gray-600 object-contain">
                    <span class="text-xs font-semibold text-sky-400">Action ${actionIndex + 1}</span>
                    <button class="ml-auto text-red-400 hover:text-red-300 text-xl font-bold">&times;</button>
                </div>
                <label class="text-xs flex items-center space-x-2">
                    <span class="w-24">Duration:</span>
                    <input type="number" value="${action.duration}" min="1" class="bg-gray-900 rounded flex-1 p-1 text-center duration-input">
                    <span class="text-gray-400">frames</span>
                </label>
                <label class="text-xs flex items-center space-x-2">
                    <span class="w-24">Rotation:</span>
                    <input type="range" min="0" max="360" value="${action.rotation}" class="flex-1 h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer rotation-slider">
                    <span class="text-sky-400 font-bold w-12 text-center rotation-value">${action.rotation}Â°</span>
                </label>
            `;
            
            const durationInput = actionEl.querySelector('.duration-input');
            const rotationSlider = actionEl.querySelector('.rotation-slider');
            const rotationValue = actionEl.querySelector('.rotation-value');
            const deleteBtn = actionEl.querySelector('button');

            durationInput.addEventListener('change', (e) => {
                wp.stopActions[actionIndex].duration = Math.max(1, parseInt(e.target.value) || 1);
            });

            rotationSlider.addEventListener('input', (e) => {
                const rotation = parseInt(e.target.value);
                wp.stopActions[actionIndex].rotation = rotation;
                rotationValue.textContent = `${rotation}Â°`;
                draw();
            });

            deleteBtn.addEventListener('click', () => {
                if (wp.stopActions.length > 1) {
                    wp.stopActions.splice(actionIndex, 1);
                    renderStopActions(waypointIndex);
                    draw();
                } else {
                    showInfo("A waypoint must have at least one action.");
                }
            });

            stopActionsList.appendChild(actionEl);
        });
    }
    
    function deselectWaypoint() {
        selectedWaypointIndex = -1;
        waypointEditor.classList.add('hidden');
        renderWaypointsList();
    }

    function handleHeadingChange(e) {
        if (selectedWaypointIndex !== -1) {
            const sprite = getActiveSprite();
            const newHeading = parseInt(e.target.value);
            sprite.waypoints[selectedWaypointIndex].heading = newHeading;
            headingValue.textContent = `${newHeading}Â°`;
            renderWaypointsList();
            draw();
        }
    }
    
    function deleteSelectedWaypoint() {
        if (selectedWaypointIndex !== -1) {
            const sprite = getActiveSprite();
            sprite.waypoints.splice(selectedWaypointIndex, 1);
            deselectWaypoint();
            if(sprite.waypoints.length > 0) selectWaypoint(sprite.waypoints.length - 1);
            else renderWaypointsList();
            renderSpriteList();
            draw();
        }
    }

    function clearWaypoints() {
        if (confirm('Are you sure you want to clear all waypoints for this sprite?')) {
            const sprite = getActiveSprite();
            sprite.waypoints = [];
            deselectWaypoint();
            renderSpriteList();
            renderWaypointsList();
            draw();
        }
    }
    
    function showInfo(message) {
        infoText.textContent = message;
        infoBox.classList.remove('hidden');
        setTimeout(() => infoBox.classList.add('hidden'), 3000);
    }

    // --- Pan/Zoom Functions ---
    function handleMouseDown(e) {
        // Allow panning anytime except when clicking to add waypoints
        if (animationFrameId) return; // Don't pan during animation
        
        // Check if clicking on a waypoint or empty space
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;
        const x = (canvasX - panX) / zoomLevel;
        const y = (canvasY - panY) / zoomLevel;
        
        // Check if clicking on a waypoint to drag it
        const sprite = getActiveSprite();
        if (!sprite.isStatic) {
            const clickedWaypointIndex = sprite.waypoints.findIndex(wp => Math.sqrt((wp.x - x)**2 + (wp.y - y)**2) < 15);
            if (clickedWaypointIndex !== -1 && !isRecording) {
                isDraggingWaypoint = true;
                draggedWaypointIndex = clickedWaypointIndex;
                canvas.style.cursor = 'move';
                return;
            }
        }
        
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartPanX = panX;
        dragStartPanY = panY;
        canvas.style.cursor = 'grabbing';
    }

    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const canvasX = (e.clientX - rect.left) * scaleX;
        const canvasY = (e.clientY - rect.top) * scaleY;
        let x = (canvasX - panX) / zoomLevel;
        let y = (canvasY - panY) / zoomLevel;
        
        // Handle waypoint dragging
        if (isDraggingWaypoint && draggedWaypointIndex !== -1) {
            const sprite = getActiveSprite();
            // Shift key: constrain to straight lines from previous waypoint
            if (isShiftPressed && draggedWaypointIndex > 0) {
                const prevWp = sprite.waypoints[draggedWaypointIndex - 1];
                const dx = Math.abs(x - prevWp.x);
                const dy = Math.abs(y - prevWp.y);
                
                // Lock to whichever axis has more movement
                if (dx > dy) {
                    y = prevWp.y; // Horizontal line
                } else {
                    x = prevWp.x; // Vertical line
                }
            }
            
            sprite.waypoints[draggedWaypointIndex].x = x;
            sprite.waypoints[draggedWaypointIndex].y = y;
            draw();
            return;
        }
        
        // Handle canvas panning
        if (isDragging) {
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            panX = dragStartPanX + dx;
            panY = dragStartPanY + dy;
            updatePanZoomInfo();
            if (animationFrameId) {
                drawWithTransform();
            } else {
                draw();
            }
            return;
        }
        
        // Update hover state for cursor feedback
        if (!animationFrameId && !isRecording) {
            const sprite = getActiveSprite();
            const hoveredIndex = sprite.waypoints.findIndex(wp => Math.sqrt((wp.x - x)**2 + (wp.y - y)**2) < 15);
            if (hoveredIndex !== -1) {
                hoveredWaypointIndex = hoveredIndex;
                canvas.style.cursor = 'move';
            } else {
                hoveredWaypointIndex = -1;
                canvas.style.cursor = 'grab';
            }
            if (hoveredIndex !== hoveredWaypointIndex) {
                draw();
            }
        }
    }

    function handleMouseUp(e) {
        if (isDraggingWaypoint) {
            isDraggingWaypoint = false;
            draggedWaypointIndex = -1;
            canvas.style.cursor = 'grab';
            draw();
        }
        if (isDragging) {
            isDragging = false;
            canvas.style.cursor = (isPaused || !isRecording) ? 'grab' : 'default';
        }
    }

    function handleWheel(e) {
        // Allow zooming anytime except during animation setup
        if (animationFrameId && !isRecording) return;
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.5, Math.min(3, zoomLevel * delta));
        
        // Zoom towards mouse position
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        
        panX = mouseX - (mouseX - panX) * (newZoom / zoomLevel);
        panY = mouseY - (mouseY - panY) * (newZoom / zoomLevel);
        zoomLevel = newZoom;
        
        updatePanZoomInfo();
        if (animationFrameId) {
            drawWithTransform();
        } else {
            draw();
        }
    }

    function handleKeyDown(e) {
        if (e.code === 'Space' && isRecording) {
            e.preventDefault();
            togglePause();
        }
        if (e.key === 'Shift') {
            isShiftPressed = true;
        }
    }
    
    document.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
            isShiftPressed = false;
        }
    });

    function togglePause() {
        isPaused = !isPaused;
        canvas.style.cursor = isPaused ? 'grab' : 'default';
        pauseStatus.textContent = isPaused ? 'PAUSED' : 'Recording';
        pauseStatus.className = isPaused ? 'text-yellow-400' : 'text-green-400';
    }

    function resetView() {
        panX = 0;
        panY = 0;
        zoomLevel = 1;
        updatePanZoomInfo();
        drawWithTransform();
    }

    function updatePanZoomInfo() {
        const panText = `${Math.round(panX)}, ${Math.round(panY)}`;
        const zoomText = `${Math.round(zoomLevel * 100)}%`;
        
        panInfo.textContent = panText;
        zoomInfo.textContent = zoomText;
        panInfoPreview.textContent = panText;
        zoomInfoPreview.textContent = zoomText;
    }

    function drawWithTransform() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Use stored recording pan/zoom if recording, otherwise current pan/zoom
        const usePanX = (isRecording && window.recordingPanX !== undefined) ? window.recordingPanX : panX;
        const usePanY = (isRecording && window.recordingPanY !== undefined) ? window.recordingPanY : panY;
        const useZoom = (isRecording && window.recordingZoom !== undefined) ? window.recordingZoom : zoomLevel;
        
        ctx.translate(usePanX, usePanY);
        ctx.scale(useZoom, useZoom);
        
        // Draw background
        if (!useBackground) {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else if (fieldImage) {
            ctx.drawImage(fieldImage, 0, 0, canvas.width, canvas.height);
        }
        
        // Draw all sprites
        spriteInstances.forEach(sprite => {
            if (sprite.isStatic) {
                // Draw static sprite at its fixed position
                if (robotSprites[sprite.defaultSpriteIndex]) {
                    drawRobot(robotSprites[sprite.defaultSpriteIndex], sprite.staticX, sprite.staticY, sprite.staticHeading, sprite.size);
                }
            } else if (sprite.state.phase !== 'idle') {
                // Draw animating sprite
                drawRobot(robotSprites[sprite.state.spriteIndex], sprite.state.x, sprite.state.y, sprite.state.heading, sprite.size);
            }
        });
        
        ctx.restore();
    }

    // --- Drawing Functions ---
    function draw() {
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw background color if not using field image
        if (!useBackground) {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        ctx.translate(panX, panY);
        ctx.scale(zoomLevel, zoomLevel);
        
        if (useBackground && fieldImage) ctx.drawImage(fieldImage, 0, 0, canvas.width, canvas.height);

        // Draw all sprites (inactive ones with lower opacity)
        spriteInstances.forEach((sprite, spriteIdx) => {
            const isActive = spriteIdx === activeSpriteIndex;
            
            if (sprite.isStatic) {
                // Draw static sprite at its fixed position
                if (robotSprites[sprite.defaultSpriteIndex]) {
                    drawRobot(robotSprites[sprite.defaultSpriteIndex], sprite.staticX, sprite.staticY, sprite.staticHeading, sprite.size, isActive ? 1.0 : 0.3);
                }
            } else {
                // Draw waypoint path
                if (sprite.waypoints.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(sprite.waypoints[0].x, sprite.waypoints[0].y);
                    for (let i = 1; i < sprite.waypoints.length; i++) {
                        ctx.lineTo(sprite.waypoints[i].x, sprite.waypoints[i].y);
                    }
                    ctx.strokeStyle = isActive ? 'rgba(255, 255, 0, 0.7)' : 'rgba(255, 255, 0, 0.2)';
                    ctx.lineWidth = isActive ? 3 : 2;
                    ctx.stroke();
                }

                // Draw waypoints
                sprite.waypoints.forEach((wp, i) => {
                    const isHovered = isActive && i === hoveredWaypointIndex;
                    const radius = isHovered ? 10 : (isActive ? 8 : 5);
                    ctx.beginPath();
                    ctx.arc(wp.x, wp.y, radius, 0, Math.PI * 2);
                    const isSelected = isActive && i === selectedWaypointIndex;
                    ctx.fillStyle = isSelected ? '#38bdf8' : (isActive ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 255, 0, 0.3)');
                    ctx.fill();
                    ctx.strokeStyle = isSelected ? '#fff' : (isHovered ? '#fff' : (isActive ? '#000' : 'rgba(0,0,0,0.5)'));
                    ctx.lineWidth = isHovered ? 3 : 2;
                    ctx.stroke();

                    const lastAction = wp.stopActions[wp.stopActions.length - 1];
                    if (lastAction && robotSprites[lastAction.spriteIndex]) {
                        const rotation = wp.heading + (lastAction.rotation || 0);
                        drawRobot(robotSprites[lastAction.spriteIndex], wp.x, wp.y, rotation, sprite.size, isActive ? 0.5 : 0.2);
                    }
                });
            }
        });
        
        ctx.restore();
    }

    function drawRobot(sprite, x, y, heading, size, opacity = 1.0) {
        if (!sprite) return;
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.translate(x, y);
        ctx.rotate(heading * Math.PI / 180);
        ctx.drawImage(sprite, -size / 2, -size / 2, size, size);
        ctx.restore();
    }

    // --- Recording Logic ---
    function toggleRecording() {
        if (!isRecording) startRecording();
        else stopRecordingAndSave();
    }

    function startRecording() {
        // Check if at least one sprite has waypoints
        const hasWaypoints = spriteInstances.some(s => s.waypoints.length >= 1);
        if (!hasWaypoints) {
            showInfo("Add at least one waypoint to at least one sprite.");
            return;
        }
        if (!window.MediaRecorder) {
            showInfo("Sorry, your browser does not support video recording.");
            return;
        }
        const stream = canvas.captureStream(30);
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        recordedChunks = [];
    // If present, disable export buttons until this recording finishes
    if (convertGifBtn) convertGifBtn.disabled = true;
    if (downloadWebmBtn) downloadWebmBtn.disabled = true;
    if (exportOptions) exportOptions.classList.add('hidden');
        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            lastRecordingBlob = blob;
            // Enable export buttons now that we have a recording (if present)
            if (convertGifBtn) convertGifBtn.disabled = false;
            if (downloadWebmBtn) downloadWebmBtn.disabled = false;
            if (exportOptions) exportOptions.classList.remove('hidden');
            // Open modal to choose filename and then trigger download
            openRenameModal();
        };
        mediaRecorder.start(100); // Request data every 100ms
        isRecording = true;
        isPaused = false;
        // Don't reset panX, panY, zoomLevel - preserve user's view
        recordBtn.textContent = 'Stop Recording';
        recordBtn.classList.replace('bg-red-600', 'bg-green-500');
        recordBtn.classList.replace('hover:bg-red-700', 'hover:bg-green-600');
        panZoomControls.classList.remove('hidden');
        updatePanZoomInfo();
        startAnimation();
    }
    
    function stopRecordingAndSave() {
        if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
        isRecording = false;
        isPaused = false;
        // Clean up stored recording pan/zoom
        delete window.recordingPanX;
        delete window.recordingPanY;
        delete window.recordingZoom;
        // Don't reset panX, panY, zoomLevel - preserve user's view
        canvas.style.cursor = 'default';
        recordBtn.textContent = 'Record';
        recordBtn.classList.replace('bg-green-500', 'bg-red-600');
        recordBtn.classList.replace('hover:bg-green-600', 'hover:bg-red-700');
        panZoomControls.classList.add('hidden');
        stopAnimation();
    }

    // --- GIF Conversion (ffmpeg.wasm) ---
    // CDN candidates for robustness
    const FFCDN_CANDIDATES = [
        // Use CDN versions for reliability - they include all necessary worker files
        {
            script: 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.js',
            coreBase: 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd'
        },
        {
            script: 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.js',
            coreBase: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd'
        }
    ];
    let chosenFfmpegCoreBase = null;

    async function ensureFFmpegLoaded() {
        if (ffmpegLoaded) return;
        
        // Debug: Check what's available in the global scope
        console.log('Checking for FFmpeg availability...');
        console.log('window.FFmpeg:', window.FFmpeg);
        console.log('window.FFmpegWASM:', window.FFmpegWASM);
        
        // Check for different possible global names and patterns
        let createFFmpegFn = null;
        
        if (window.createFFmpeg) {
            createFFmpegFn = window.createFFmpeg;
            console.log('Using window.createFFmpeg');
        } else if (window.FFmpeg && typeof window.FFmpeg === 'function') {
            // FFmpeg might be the constructor itself
            createFFmpegFn = () => new window.FFmpeg();
            console.log('Using window.FFmpeg constructor');
        } else if (window.FFmpeg && window.FFmpeg.createFFmpeg) {
            createFFmpegFn = window.FFmpeg.createFFmpeg;
            console.log('Using window.FFmpeg.createFFmpeg');
        } else if (window.FFmpegWASM && window.FFmpegWASM.createFFmpeg) {
            createFFmpegFn = window.FFmpegWASM.createFFmpeg;
            console.log('Using window.FFmpegWASM.createFFmpeg');
        } else if (window.FFmpegWASM && window.FFmpegWASM.FFmpeg) {
            const FFmpegClass = window.FFmpegWASM.FFmpeg;
            if (typeof FFmpegClass === 'function') {
                createFFmpegFn = (options) => new FFmpegClass(options);
                console.log('Using window.FFmpegWASM.FFmpeg constructor');
            }
        }
        
        if (!createFFmpegFn) {
            console.log('FFmpeg not available in window, attempting to load dynamically...');
            await loadFfmpegScriptIfNeeded();
        }
        
        // Check again after loading attempt and normalize the interface
        if (window.createFFmpeg) {
            window.FFmpeg = { createFFmpeg: window.createFFmpeg };
        } else if (window.FFmpegWASM && window.FFmpegWASM.createFFmpeg) {
            window.FFmpeg = window.FFmpegWASM;
        } else if (window.FFmpegWASM && window.FFmpegWASM.FFmpeg) {
            const FFmpegClass = window.FFmpegWASM.FFmpeg;
            window.FFmpeg = { 
                createFFmpeg: (options) => new FFmpegClass(options)
            };
        }
        
        if (!window.FFmpeg || !window.FFmpeg.createFFmpeg) {
            console.error('FFmpeg library not available after loading attempts');
            throw new Error('FFmpeg not available');
        }

        const coreBasesToTry = [];
        if (chosenFfmpegCoreBase) coreBasesToTry.push(chosenFfmpegCoreBase);
        // Add all candidates to try (dedup)
        for (const c of FFCDN_CANDIDATES) {
            if (!coreBasesToTry.includes(c.coreBase)) coreBasesToTry.push(c.coreBase);
        }

        let lastErr = null;
        setGifStatus('Loading FFmpeg (first time can take ~10â€“20s)...', true);
        for (const coreBase of coreBasesToTry) {
            try {
                console.log('Trying FFmpeg with coreBase:', coreBase);
                // Use the normalized FFmpeg interface
                if (!window.FFmpeg || !window.FFmpeg.createFFmpeg) {
                    throw new Error('FFmpeg interface not available');
                }
                
                ffmpegInstance = window.FFmpeg.createFFmpeg({
                    log: true,
                    corePath: `${coreBase}/ffmpeg-core.js`
                });
                await ffmpegInstance.load();
                console.log('FFmpeg loaded successfully with coreBase:', coreBase);
                ffmpegLoaded = true;
                setGifStatus('FFmpeg ready.', false);
                return;
            } catch (e) {
                console.warn('FFmpeg load failed for coreBase:', coreBase, e);
                lastErr = e;
            }
        }
        setGifStatus('');
        throw (lastErr || new Error('FFmpeg not available'));
    }

    function loadScript(src) {
        return new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = src;
            s.async = true;
            s.onload = () => resolve();
            s.onerror = () => reject(new Error('Failed to load script: ' + src));
            document.head.appendChild(s);
        });
    }

    async function loadFfmpegScriptIfNeeded() {
        // Check if FFmpeg is already available in any form
        const isFFmpegAvailable = () => {
            return (window.createFFmpeg) ||
                   (window.FFmpeg && window.FFmpeg.createFFmpeg) ||
                   (window.FFmpegWASM && (window.FFmpegWASM.createFFmpeg || window.FFmpegWASM.FFmpeg));
        };
        
        if (isFFmpegAvailable()) {
            console.log('FFmpeg already available from HTML script tag or previous load');
            return;
        }
        
        console.log('Attempting to load FFmpeg dynamically...');
        for (const candidate of FFCDN_CANDIDATES) {
            try {
                console.log('Trying to load FFmpeg from:', candidate.script);
                await loadScript(candidate.script);
                if (isFFmpegAvailable()) {
                    console.log('Successfully loaded FFmpeg from:', candidate.script);
                    chosenFfmpegCoreBase = candidate.coreBase;
                    return;
                }
            } catch (e) {
                console.warn('Failed to load FFmpeg from', candidate.script, e);
            }
        }
        console.error('All FFmpeg loading attempts failed');
    }

    function setGifStatus(text, showSpinner = false) {
        gifStatus.textContent = text || '';
        gifStatus.classList.toggle('hidden', !text);
    }

    function openRenameModal() {
        // Seed with last used or default
        renameInput.value = lastRecordingBaseName || 'robot-animation';
        renameModal.classList.remove('hidden');
        // Use flex to center
        renameModal.classList.add('flex');
        // Focus input after paint
        setTimeout(() => { renameInput.focus(); renameInput.select(); }, 0);
    }

    function closeRenameModal() {
        renameModal.classList.add('hidden');
        renameModal.classList.remove('flex');
    }

    function downloadRecordedWithName(baseName) {
        if (!lastRecordingBlob) return;
        const url = URL.createObjectURL(lastRecordingBlob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = `${baseName}.webm`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }

    function onRenameSaveWebM() {
        let name = sanitizeFilename(renameInput.value);
        if (!name) name = 'robot-animation';
        lastRecordingBaseName = name;
        downloadRecordedWithName(lastRecordingBaseName);
        closeRenameModal();
    }

    function onRenameSaveGIF() {
        let name = sanitizeFilename(renameInput.value);
        if (!name) name = 'robot-animation';
        lastRecordingBaseName = name;
        closeRenameModal();
        // Trigger GIF conversion using the chosen name
        convertRecordedToGIF();
    }

    function onRenameCancel() {
        // Cancel: do not download anything; just close the modal and return
        closeRenameModal();
    }

    async function convertRecordedToGIF() {
        try {
            if (!lastRecordingBlob) {
                showInfo('No recording available. Record first.');
                return;
            }
            if (convertGifBtn) convertGifBtn.disabled = true;
            
            console.log('Starting GIF conversion process...');
            console.log('Recording blob size:', lastRecordingBlob.size, 'bytes');
            
            // Try Cloudinary first if configured (more reliable)
            if (cloudinaryConfig.enabled && cloudinaryConfig.cloudName && cloudinaryConfig.uploadPreset) {
                console.log('Using Cloudinary for GIF conversion (primary method)...');
                setGifStatus('Converting via Cloudinary...', false);
                await convertRecordedToGifViaCloudinary();
                return;
            }
            
            // Fallback to FFmpeg if Cloudinary is not configured
            setGifStatus('Preparing local FFmpeg converter...');
            try {
                await ensureFFmpegLoaded();
                console.log('FFmpeg loaded successfully, proceeding with local conversion...');
            } catch (e) {
                console.warn('FFmpeg load failed and no Cloudinary configured', e);
                setGifStatus('GIF conversion failed: FFmpeg unavailable and Cloudinary not configured.', false);
                showInfo('GIF conversion failed. FFmpeg could not load and Cloudinary is not configured.');
                throw e;
            }

            // Write input
            setGifStatus('Preparing input...');
            const inputName = 'input.webm';
            const paletteName = 'palette.png';
            const outputName = 'output.gif';
            // Clean up any previous run
            try { ffmpegInstance.FS('unlink', inputName); } catch (e) {}
            try { ffmpegInstance.FS('unlink', paletteName); } catch (e) {}
            try { ffmpegInstance.FS('unlink', outputName); } catch (e) {}

            const data = await lastRecordingBlob.arrayBuffer();
            ffmpegInstance.FS('writeFile', inputName, new Uint8Array(data));

            // Recommended two-pass palette method for better colors/size
            const fps = 12; // adjust for size/quality
            const width = 480; // scale width, keep aspect

            setGifStatus('Generating palette...');
            await ffmpegInstance.run(
                '-i', inputName,
                '-vf', `fps=${fps},scale=${width}:-1:flags=lanczos,palettegen=stats_mode=single`,
                '-y', paletteName
            );

            setGifStatus('Creating GIF (this can take a bit)...');
            await ffmpegInstance.run(
                '-i', inputName,
                '-i', paletteName,
                '-filter_complex', `[0:v] fps=${fps},scale=${width}:-1:flags=lanczos [x]; [x][1:v] paletteuse=dither=bayer:bayer_scale=5`,
                '-loop', '0',
                '-y', outputName
            );

            const out = ffmpegInstance.FS('readFile', outputName);
            const gifBlob = new Blob([out.buffer], { type: 'image/gif' });
            const url = URL.createObjectURL(gifBlob);

            // Download the GIF
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `${lastRecordingBaseName || 'robot-animation'}.gif`;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);

            setGifStatus('GIF ready and downloaded.');
        } catch (err) {
            console.error(err);
            showInfo('GIF conversion failed. See console for details.');
            setGifStatus('GIF conversion failed.');
        } finally {
            if (convertGifBtn) convertGifBtn.disabled = false;
        }
    }

    // --- Cloudinary fallback path (client-only, free tier friendly) ---
    async function convertRecordedToGifViaCloudinary() {
        try {
            console.log('Starting Cloudinary conversion...');
            console.log('Cloudinary config:', { ...cloudinaryConfig, uploadPreset: '[hidden]' });
            
            setGifStatus('Uploading to Cloudinary...');
            const uploadUrl = `https://api.cloudinary.com/v1_1/${cloudinaryConfig.cloudName}/video/upload`;
            console.log('Upload URL:', uploadUrl);
            
            const form = new FormData();
            form.append('file', lastRecordingBlob, `${lastRecordingBaseName || 'robot-animation'}.webm`);
            form.append('upload_preset', cloudinaryConfig.uploadPreset);
            // Optional: set public_id to control the asset name in your media library
            form.append('public_id', lastRecordingBaseName || 'robot-animation');

            console.log('Uploading file of size:', lastRecordingBlob.size, 'bytes');
            const res = await fetch(uploadUrl, { method: 'POST', body: form });
            console.log('Upload response status:', res.status);
            
            if (!res.ok) {
                const text = await res.text();
                console.error('Cloudinary upload error response:', text);
                throw new Error('Cloudinary upload failed: ' + text);
            }
            const data = await res.json();
            console.log('Upload successful, response:', data);
            
            // Build a GIF transformation URL from the uploaded video
            // Higher quality settings: width 800, quality 100, loop enabled
            const basePublicId = data.public_id; // includes folder if any
            // Use proper Cloudinary transformation syntax to create animated GIF
            // fl_animated ensures all frames are included, fl_awebp.lossy for compression
            const transformation = 'f_gif,fl_animated,fl_lossy,w_800,q_100';
            // Cloudinary delivery URL pattern: /video/upload/<transforms>/<public_id>.gif
            const gifUrl = `https://res.cloudinary.com/${cloudinaryConfig.cloudName}/video/upload/${transformation}/${basePublicId}.gif`;

            console.log('Generated GIF URL:', gifUrl);
            setGifStatus('Generating GIF...');
            
            // First request may trigger generation. Fetch as blob so we can name it.
            const gifResp = await fetch(gifUrl, { cache: 'no-store' });
            console.log('GIF fetch response status:', gifResp.status);
            
            if (!gifResp.ok) {
                const errorText = await gifResp.text();
                console.error('GIF fetch error:', errorText);
                throw new Error('Failed to retrieve GIF: ' + errorText);
            }
            const gifBlob = await gifResp.blob();
            console.log('GIF blob size:', gifBlob.size, 'bytes');

            const url = URL.createObjectURL(gifBlob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `${lastRecordingBaseName || 'robot-animation'}.gif`;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);

            console.log('GIF download initiated successfully');
            setGifStatus('GIF ready and downloaded.');
        } catch (e) {
            console.error('Cloudinary GIF path failed', e);
            setGifStatus('Cloudinary GIF conversion failed.');
            showInfo('Cloudinary conversion failed. Please check your Cloudinary configuration (cloudName and uploadPreset) or network connection.');
            throw e; // Re-throw so the main catch block can handle it
        }
    }

    // --- Animation Logic ---
    function startAnimation() {
        // Check if at least one sprite has waypoints
        const hasWaypoints = spriteInstances.some(s => s.waypoints.length >= 1);
        if (!hasWaypoints) {
            if (!isRecording) showInfo("Add at least one waypoint to at least one sprite.");
            return;
        }
        if (animationFrameId) return;
        deselectWaypoint();
        
        // Store pan/zoom state if recording to restore later
        if (isRecording) {
            window.recordingPanX = panX;
            window.recordingPanY = panY;
            window.recordingZoom = zoomLevel;
        }
        
        // Initialize all sprites with waypoints
        spriteInstances.forEach(sprite => {
            if (sprite.waypoints.length >= 1) {
                const firstWp = sprite.waypoints[0];
                const firstAction = firstWp.stopActions[0];
                sprite.state.segmentIndex = 0;
                sprite.state.progress = 0;
                sprite.state.x = firstWp.x;
                sprite.state.y = firstWp.y;
                sprite.state.heading = firstWp.heading;
                sprite.state.spriteIndex = firstAction ? firstAction.spriteIndex : 0;
                sprite.state.phase = sprite.waypoints.length > 1 ? 'rotating' : 'dwelling';
                sprite.state.actionIndex = 0;
                sprite.state.dwellCounter = 0;
            } else {
                sprite.state.phase = 'idle';
            }
        });

        animationLoop();
    }

    function stopAnimation() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            draw();
        }
        if (isRecording) stopRecordingAndSave();
    }

    function animationLoop() {
        // Check if all sprites are idle
        const allIdle = spriteInstances.every(s => s.state.phase === 'idle');
        if (allIdle) {
            stopAnimation();
            if (!isRecording) showInfo("Animation finished!");
            return;
        }
        
        // Only update sprite states if not paused
        if (!isPaused) {
            spriteInstances.forEach(sprite => {
                if (sprite.state.phase === 'idle' || sprite.waypoints.length < 1) return;
                
                const currentWp = sprite.waypoints[sprite.state.segmentIndex];

                if (sprite.state.phase === 'rotating') {
                    const rotationSpeed = sprite.state.baseRotationSpeed * playbackSpeed;
                    const angleDiff = ((((currentWp.heading - sprite.state.heading) % 360) + 540) % 360) - 180;
                    if (Math.abs(angleDiff) < rotationSpeed) {
                        sprite.state.heading = currentWp.heading;
                        sprite.state.phase = 'dwelling';
                        sprite.state.actionIndex = 0;
                        sprite.state.dwellCounter = 0;
                    } else {
                        sprite.state.heading += Math.sign(angleDiff) * rotationSpeed;
                    }
                } 
                else if (sprite.state.phase === 'dwelling') {
                    const currentAction = currentWp.stopActions[sprite.state.actionIndex];
                    if (!currentAction) {
                        if (sprite.state.segmentIndex >= sprite.waypoints.length - 1) {
                            sprite.state.phase = 'idle';
                        } else {
                            sprite.state.phase = 'moving';
                        }
                    } else {
                        sprite.state.spriteIndex = currentAction.spriteIndex;
                        sprite.state.heading = currentWp.heading + (currentAction.rotation || 0);
                        sprite.state.dwellCounter += playbackSpeed;
                        if (sprite.state.dwellCounter >= currentAction.duration) {
                            sprite.state.actionIndex++;
                            sprite.state.dwellCounter = 0;
                        }
                    }
                }
                else if (sprite.state.phase === 'moving') {
                    const startWp = currentWp;
                    const endWp = sprite.waypoints[sprite.state.segmentIndex + 1];
                    const dx = endWp.x - startWp.x;
                    const dy = endWp.y - startWp.y;
                    const distance = Math.sqrt(dx*dx + dy*dy);

                    // Set heading and sprite based on the waypoint we just left
                    const lastAction = startWp.stopActions[startWp.stopActions.length - 1];
                    sprite.state.heading = startWp.heading + (lastAction.rotation || 0);
                    sprite.state.spriteIndex = lastAction.spriteIndex;

                    if (distance > 0) {
                        const speed = sprite.state.baseSpeed * playbackSpeed;
                        sprite.state.progress += speed;
                        if (sprite.state.progress >= distance) {
                            sprite.state.segmentIndex++;
                            sprite.state.progress = 0;
                            sprite.state.x = endWp.x;
                            sprite.state.y = endWp.y;
                            sprite.state.phase = 'rotating';
                        } else {
                            const progressRatio = sprite.state.progress / distance;
                            sprite.state.x = startWp.x + dx * progressRatio;
                            sprite.state.y = startWp.y + dy * progressRatio;
                        }
                    } else { // Waypoints are on top of each other
                        sprite.state.segmentIndex++;
                        sprite.state.phase = 'rotating';
                    }
                }
            });
        }

        // Always render (even when paused, to show pan/zoom changes)
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw background color if not using field image
        if (!useBackground) {
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        ctx.translate(panX, panY);
        ctx.scale(zoomLevel, zoomLevel);
        
        if (useBackground && fieldImage) ctx.drawImage(fieldImage, 0, 0, canvas.width, canvas.height);
        
        // Draw all sprites
        spriteInstances.forEach(sprite => {
            if (sprite.isStatic) {
                // Draw static sprite at its fixed position
                if (robotSprites[sprite.defaultSpriteIndex]) {
                    drawRobot(robotSprites[sprite.defaultSpriteIndex], sprite.staticX, sprite.staticY, sprite.staticHeading, sprite.size);
                }
            } else if (sprite.state.phase !== 'idle') {
                // Draw animating sprite
                drawRobot(robotSprites[sprite.state.spriteIndex], sprite.state.x, sprite.state.y, sprite.state.heading, sprite.size);
            }
        });
        
        ctx.restore();

        animationFrameId = requestAnimationFrame(animationLoop);
    }
    
    // Simple filename sanitizer: keep letters, numbers, space, underscore, dash, dot
    function sanitizeFilename(name) {
        if (!name) return '';
        let n = String(name).trim();
        n = n.replace(/[^a-zA-Z0-9 _.-]/g, '_'); // invalid chars -> _
        n = n.replace(/\s+/g, ' '); // collapse spaces
        n = n.replace(/^[ .]+|[ .]+$/g, ''); // trim dots/spaces
        if (!n) return '';
        return n.substring(0, 128);
    }

    init();
</script>
</body>
</html>
